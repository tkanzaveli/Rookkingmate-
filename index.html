<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Queen's Club - Checkmate Training</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            background: #2c3e50;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        .container {
            background: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            max-width: 600px;
            width: 100%;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .logo {
            font-size: 28px;
            font-weight: bold;
            color: #c41e3a;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        h1 {
            color: #333;
            font-size: 24px;
            margin: 10px 0;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            gap: 10px;
        }

        .stat {
            background: #f0f0f0;
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: bold;
            flex: 1;
            text-align: center;
        }

        #board {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            gap: 0;
            margin: 0 auto 20px;
            border: 3px solid #333;
        }

        .square {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            cursor: pointer;
            position: relative;
        }

        .white {
            background: #f0d9b5;
        }

        .black {
            background: #b58863;
        }

        .selected {
            background: #ffeb3b !important;
            box-shadow: inset 0 0 0 3px #ffc107;
        }

        .valid-move {
            background: #8bc34a !important;
        }

        .valid-move::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: rgba(76, 175, 80, 0.5);
            border-radius: 50%;
        }

        .in-check {
            background: #ff5252 !important;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: inset 0 0 0 0 rgba(255, 0, 0, 0.7); }
            50% { box-shadow: inset 0 0 0 5px rgba(255, 0, 0, 0.7); }
            100% { box-shadow: inset 0 0 0 0 rgba(255, 0, 0, 0.7); }
        }

        .controls {
            text-align: center;
            margin-top: 20px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        button {
            background: #c41e3a;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: background 0.3s;
        }

        button:hover {
            background: #a01729;
        }

        #message {
            text-align: center;
            margin: 20px 0;
            font-size: 18px;
            color: #333;
            min-height: 30px;
        }

        .error {
            color: #f44336;
            font-weight: bold;
        }

        .success {
            color: #4caf50;
            font-weight: bold;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            max-width: 400px;
        }

        .trophy {
            font-size: 60px;
            margin: 20px 0;
        }

        .debug {
            font-size: 11px;
            color: #666;
            margin-top: 10px;
            text-align: center;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="logo">
                <span>‚ôõ</span>
                <span>Chess Queen's Club</span>
            </div>
            <h1>King & Rook Checkmate Training</h1>
        </div>

        <div class="stats">
            <div class="stat">Moves: <span id="moves">0</span></div>
            <div class="stat">Time: <span id="time">0:00</span></div>
            <div class="stat">Score: <span id="score">1000</span></div>
        </div>

        <div id="message">Click your King or Rook to start!</div>

        <div id="board"></div>

        <div class="controls">
            <button onclick="resetGame()">New Game</button>
            <button onclick="getHint()">Hint</button>
        </div>

        <div id="debug" class="debug"></div>
    </div>

    <div id="winModal" class="modal">
        <div class="modal-content">
            <div class="trophy">üèÜ</div>
            <h2>Checkmate! Excellent Work!</h2>
            <p id="finalStats"></p>
            <button onclick="closeWinModal()">Play Again</button>
        </div>
    </div>

    <script>
        // Game state
        let board = [];
        let selected = null;
        let moves = 0;
        let score = 1000;
        let startTime = Date.now();
        let timerInterval;
        let gameOver = false;

        // Piece positions
        let whiteKing = null;
        let whiteRook = null;
        let blackKing = null;

        // Initialize board
        function initBoard() {
            board = Array(8).fill(null).map(() => Array(8).fill(null));
            
            // Place pieces with valid starting positions
            // Place white king
            whiteKing = {
                row: Math.floor(Math.random() * 8),
                col: Math.floor(Math.random() * 8)
            };
            
            // Place white rook (not on king)
            do {
                whiteRook = {
                    row: Math.floor(Math.random() * 8),
                    col: Math.floor(Math.random() * 8)
                };
            } while (whiteRook.row === whiteKing.row && whiteRook.col === whiteKing.col);
            
            // Place black king (not adjacent to white king, not on other pieces)
            let blackKingPlaced = false;
            while (!blackKingPlaced) {
                blackKing = {
                    row: Math.floor(Math.random() * 8),
                    col: Math.floor(Math.random() * 8)
                };
                
                // Check not on another piece
                if ((blackKing.row === whiteKing.row && blackKing.col === whiteKing.col) ||
                    (blackKing.row === whiteRook.row && blackKing.col === whiteRook.col)) {
                    continue;
                }
                
                // Check not adjacent to white king
                if (Math.abs(blackKing.row - whiteKing.row) <= 1 && 
                    Math.abs(blackKing.col - whiteKing.col) <= 1) {
                    continue;
                }
                
                blackKingPlaced = true;
            }
            
            // Place pieces on board
            board[whiteKing.row][whiteKing.col] = '‚ôî';
            board[whiteRook.row][whiteRook.col] = '‚ôñ';
            board[blackKing.row][blackKing.col] = '‚ôö';
        }

        // Render board
        function renderBoard() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            
            // Check if black king is in check
            let blackKingInCheck = isSquareAttackedByWhite(blackKing.row, blackKing.col);
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = 'square ' + ((row + col) % 2 === 0 ? 'white' : 'black');
                    
                    // Highlight if black king is in check
                    if (blackKingInCheck && row === blackKing.row && col === blackKing.col) {
                        square.classList.add('in-check');
                    }
                    
                    square.dataset.row = row;
                    square.dataset.col = col;
                    
                    if (board[row][col]) {
                        square.textContent = board[row][col];
                    }
                    
                    square.onclick = () => handleClick(row, col);
                    boardEl.appendChild(square);
                }
            }
            
            // Update debug info
            updateDebug();
        }

        // Check if a square is attacked by white pieces
        function isSquareAttackedByWhite(row, col) {
            // Check if attacked by white king
            if (Math.abs(row - whiteKing.row) <= 1 && 
                Math.abs(col - whiteKing.col) <= 1) {
                return true;
            }
            
            // Check if attacked by white rook
            if (row === whiteRook.row || col === whiteRook.col) {
                // Check if on same rank
                if (row === whiteRook.row) {
                    let start = Math.min(col, whiteRook.col);
                    let end = Math.max(col, whiteRook.col);
                    let blocked = false;
                    
                    // Check for blocking pieces between rook and target
                    for (let c = start + 1; c < end; c++) {
                        if (board[row][c]) {
                            blocked = true;
                            break;
                        }
                    }
                    
                    if (!blocked) return true;
                }
                // Check if on same file
                else if (col === whiteRook.col) {
                    let start = Math.min(row, whiteRook.row);
                    let end = Math.max(row, whiteRook.row);
                    let blocked = false;
                    
                    // Check for blocking pieces between rook and target
                    for (let r = start + 1; r < end; r++) {
                        if (board[r][col]) {
                            blocked = true;
                            break;
                        }
                    }
                    
                    if (!blocked) return true;
                }
            }
            
            return false;
        }

        // Handle square click
        function handleClick(row, col) {
            if (gameOver) return;
            
            const piece = board[row][col];
            
            if (selected) {
                // Try to move
                if (isValidMove(selected, {row, col})) {
                    makeMove(selected, {row, col});
                }
                clearSelection();
            } else if (piece === '‚ôî' || piece === '‚ôñ') {
                // Select piece
                selected = {row, col, piece};
                highlightSelection();
            }
        }

        // Check if move is valid for white pieces
        function isValidMove(from, to) {
            // Can't capture own pieces
            if (board[to.row][to.col] === '‚ôî' || board[to.row][to.col] === '‚ôñ') {
                return false;
            }
            
            if (from.piece === '‚ôî') {
                // King moves one square
                const rowDiff = Math.abs(from.row - to.row);
                const colDiff = Math.abs(from.col - to.col);
                if (rowDiff > 1 || colDiff > 1) return false;
                
                // Can't move next to black king
                if (board[to.row][to.col] !== '‚ôö') { // Unless capturing
                    if (Math.abs(to.row - blackKing.row) <= 1 && 
                        Math.abs(to.col - blackKing.col) <= 1) {
                        return false;
                    }
                }
                return true;
            } else if (from.piece === '‚ôñ') {
                // Rook moves in straight lines
                if (from.row !== to.row && from.col !== to.col) return false;
                
                // Check path is clear
                if (from.row === to.row) {
                    let start = Math.min(from.col, to.col);
                    let end = Math.max(from.col, to.col);
                    for (let i = start + 1; i < end; i++) {
                        if (board[from.row][i]) return false;
                    }
                } else {
                    let start = Math.min(from.row, to.row);
                    let end = Math.max(from.row, to.row);
                    for (let i = start + 1; i < end; i++) {
                        if (board[i][from.col]) return false;
                    }
                }
                return true;
            }
            return false;
        }

        // Make move
        function makeMove(from, to) {
            // Check if capturing black king (shouldn't happen in normal play)
            if (board[to.row][to.col] === '‚ôö') {
                gameOver = true;
                showMessage("Black king captured! This shouldn't happen!", true);
                setTimeout(() => resetGame(), 2000);
                return;
            }
            
            // Make the move
            board[to.row][to.col] = board[from.row][from.col];
            board[from.row][from.col] = null;
            
            // Update piece positions
            if (from.piece === '‚ôî') {
                whiteKing = {row: to.row, col: to.col};
            } else if (from.piece === '‚ôñ') {
                whiteRook = {row: to.row, col: to.col};
            }
            
            moves++;
            score = Math.max(100, score - 10);
            updateStats();
            renderBoard();
            
            // Show encouragement
            if (moves % 5 === 0) {
                showMessage("Good progress! Keep going!");
            }
            
            // Black king moves after a delay
            setTimeout(() => {
                if (!gameOver) {
                    moveBlackKing();
                }
            }, 500);
        }

        // Move black king
        function moveBlackKing() {
            if (gameOver) return;
            
            // Get all possible moves for black king
            let possibleMoves = [];
            
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue; // Skip current position
                    
                    let newRow = blackKing.row + dr;
                    let newCol = blackKing.col + dc;
                    
                    // Check if move is within board
                    if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                        // Check if square is empty
                        if (!board[newRow][newCol]) {
                            // Check if square is safe (not attacked)
                            if (!isSquareAttackedByWhite(newRow, newCol)) {
                                possibleMoves.push({
                                    row: newRow, 
                                    col: newCol,
                                    // Add preference score (prefer center squares)
                                    score: Math.min(newRow, 7 - newRow) + Math.min(newCol, 7 - newCol)
                                });
                            }
                        }
                    }
                }
            }
            
            // If no valid moves, check for checkmate or stalemate
            if (possibleMoves.length === 0) {
                let inCheck = isSquareAttackedByWhite(blackKing.row, blackKing.col);
                if (inCheck) {
                    // Checkmate!
                    gameOver = true;
                    showWin();
                } else {
                    // Stalemate
                    gameOver = true;
                    showMessage("Stalemate! The black king has no legal moves but is not in check.", true);
                    setTimeout(() => resetGame(), 3000);
                }
                return;
            }
            
            // Choose a move (prefer center squares when possible)
            possibleMoves.sort((a, b) => b.score - a.score);
            let move = possibleMoves[0];
            
            // Make the move
            board[blackKing.row][blackKing.col] = null;
            blackKing = {row: move.row, col: move.col};
            board[blackKing.row][blackKing.col] = '‚ôö';
            
            renderBoard();
            
            // Check if we're making progress
            if (blackKing.row === 0 || blackKing.row === 7 || 
                blackKing.col === 0 || blackKing.col === 7) {
                showMessage("Good! The black king is on the edge. Now keep it there!");
            }
        }

        // Highlight selection and valid moves
        function highlightSelection() {
            clearHighlights();
            
            const squares = document.querySelectorAll('.square');
            squares.forEach(sq => {
                let row = parseInt(sq.dataset.row);
                let col = parseInt(sq.dataset.col);
                
                if (row === selected.row && col === selected.col) {
                    sq.classList.add('selected');
                } else if (isValidMove(selected, {row, col})) {
                    sq.classList.add('valid-move');
                }
            });
        }

        // Clear selection
        function clearSelection() {
            selected = null;
            clearHighlights();
        }

        // Clear highlights
        function clearHighlights() {
            document.querySelectorAll('.square').forEach(sq => {
                sq.classList.remove('selected', 'valid-move');
            });
        }

        // Update stats
        function updateStats() {
            document.getElementById('moves').textContent = moves;
            document.getElementById('score').textContent = score;
        }

        // Update timer
        function updateTimer() {
            if (gameOver) return;
            
            let elapsed = Math.floor((Date.now() - startTime) / 1000);
            let minutes = Math.floor(elapsed / 60);
            let seconds = elapsed % 60;
            document.getElementById('time').textContent = 
                minutes + ':' + (seconds < 10 ? '0' : '') + seconds;
        }

        // Show message
        function showMessage(text, isError = false) {
            const msgEl = document.getElementById('message');
            msgEl.textContent = text;
            msgEl.className = isError ? 'error' : '';
        }

        // Update debug info
        function updateDebug() {
            const inCheck = isSquareAttackedByWhite(blackKing.row, blackKing.col);
            document.getElementById('debug').textContent = 
                `WK: ${whiteKing.row},${whiteKing.col} | ` +
                `WR: ${whiteRook.row},${whiteRook.col} | ` +
                `BK: ${blackKing.row},${blackKing.col} | ` +
                `Check: ${inCheck ? 'YES' : 'NO'}`;
        }

        // Show win modal
        function showWin() {
            clearInterval(timerInterval);
            let time = Math.floor((Date.now() - startTime) / 1000);
            let minutes = Math.floor(time / 60);
            let seconds = time % 60;
            
            let stars = moves <= 25 ? '‚≠ê‚≠ê‚≠ê' : moves <= 50 ? '‚≠ê‚≠ê' : '‚≠ê';
            
            document.getElementById('finalStats').innerHTML = 
                `${stars}<br><br>
                <strong>Moves:</strong> ${moves}<br>
                <strong>Time:</strong> ${minutes}:${seconds < 10 ? '0' : ''}${seconds}<br>
                <strong>Score:</strong> ${score}<br><br>
                Well done! You've mastered the King & Rook checkmate!`;
            
            document.getElementById('winModal').style.display = 'flex';
            showMessage('Checkmate! Excellent work! üéâ');
        }

        // Close win modal
        function closeWinModal() {
            document.getElementById('winModal').style.display = 'none';
            resetGame();
        }

        // Get hint
        function getHint() {
            let hints = [
                "Push the black king to the edge of the board first!",
                "Use your king to control escape squares - work as a team!",
                "The rook is most powerful when it cuts off the king's escape.",
                "Try to force the king to the edge, then to a corner.",
                "Your king should be opposite the enemy king with one square between.",
                "Once on the edge, use your rook to deliver checkmate!"
            ];
            
            // Give contextual hints
            if (blackKing.row > 1 && blackKing.row < 6 && 
                blackKing.col > 1 && blackKing.col < 6) {
                showMessage("üí° First, push the black king to the edge of the board!");
            } else {
                showMessage("üí° " + hints[Math.floor(Math.random() * hints.length)]);
            }
            
            score = Math.max(100, score - 50);
            updateStats();
        }

        // Reset game
        function resetGame() {
            gameOver = false;
            moves = 0;
            score = 1000;
            startTime = Date.now();
            selected = null;
            
            clearInterval(timerInterval);
            timerInterval = setInterval(updateTimer, 1000);
            
            document.getElementById('winModal').style.display = 'none';
            showMessage('Click your King or Rook to start!');
            
            initBoard();
            renderBoard();
            updateStats();
        }

        // Start game
        resetGame();
    </script>
</body>
</html>